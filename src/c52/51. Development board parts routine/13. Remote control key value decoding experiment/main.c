/********************************* 深圳市航太电子有限公司 *******************************
* 实 验 名 ：遥控键值解码
* 实验说明 ：烧录成功后，使用遥控器对着红外接收头按键，数码管会显示相应的键值
* 实验平台 ：航太51单片机开发板
* 连接方式 ：CN18的HW_RD接CN14的P32
* 注    意 ：请务必断开跳线帽CN26
* 作    者 ：航太电子产品研发部    QQ ：1909197536
* 店    铺 ：http://shop120013844.taobao.com/
****************************************************************************************/

#include <reg52.h>
#include <intrins.h>

#define FOSC 11059200L //晶振设置，默认使用11.0592M Hz
//#define FOSC 12000000L //晶振设置，使用12M Hz
//#define FOSC 24000000L //晶振设置，使用24M Hz

//IO接口定义
#define LED_PORT P0
sbit wela_1 = P2^4;
sbit wela_2 = P2^5;
sbit wela_3 = P2^6;
sbit wela_4 = P2^7;

sbit IRIN = P3^2;         //红外接收器数据线

//全局变量定义
unsigned char IRCOM[4];
unsigned char ir_value=0;
//LED显示字模 0-F 共阳模式
unsigned code table[]= {0Xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e};
/*******************************************************************************
* 函 数 名 ：Delayms
* 函数功能 ：实现 ms级的延时
* 输    入 ：ms
* 输    出 ：无
*******************************************************************************/
void Delayms(unsigned int ms)
{
	unsigned int i,j;
	for(i=0;i<ms;i++)
	#if FOSC == 11059200L
		for(j=0;j<114;j++);
	#elif FOSC == 12000000L
	  for(j=0;j<123;j++);
	#elif FOSC == 24000000L
		for(j=0;j<249;j++);
	#else
		for(j=0;j<114;j++);
	#endif
}

/*******************************************************************************
* 函 数 名 ：LEDdisplay
* 函数功能 ：循环显示各个位上的数据
* 输    入 ：num要显示的数据
* 输    出 ：无
*******************************************************************************/
void LEDdisplay(unsigned int num)
{
	unsigned char qian,bai,shi,ge;
	qian=num/1000;
	bai=num%1000/100;
	shi=num%100/10;
	ge=num%10;
	
	wela_1 = 1;	  //关闭所有数码管
	wela_2 = 1;
	wela_3 = 1;
	wela_4 = 1;	

	wela_4=0;  //显示千位
	LED_PORT=table[qian];
	Delayms(1);
	LED_PORT = 0xff;
	wela_4=1;
	
	wela_3=0;  //显示百位
	LED_PORT=table[bai];
	Delayms(1);
	LED_PORT = 0xff;
	wela_3=1;
	
	wela_2=0;  //显示十位
	LED_PORT=table[shi];
	Delayms(1);
	LED_PORT = 0xff;
	wela_2=1;
	
	wela_1=0;  //显示个位
	LED_PORT=table[ge];
	Delayms(1);
	LED_PORT = 0xff;
}

/*******************************************************************************
* 函 数 名 ：Exit0Init
* 函数功能 ：外中断0初始化程序
* 输    入 ：无
* 输    出 ：无
*******************************************************************************/
void Exit0Init()
{
	EX0 = 1;	//使能 INT1 外部中断
    IT0 = 1;	// 触发方式为脉冲负边沿触发
    EA = 1;//总中断
}  

/*******************************************************************************
* 函 数 名 ：DelayIr
* 函数功能 ：0.14MS 延时
* 输    入 ：无
* 输    出 ：无
*******************************************************************************/
void DelayIr(unsigned char x)  
{
 unsigned char i;
  while(x--)
 {
  for (i = 0; i<13; i++) {}
 }
}

/*******************************************************************************
* 函 数 名 ：main
* 函数功能 ：主函数
* 输    入 ：无
* 输    出 ：无
*******************************************************************************/
void main()
{
	IRIN=1;                    //I/O口初始化
	Exit0Init();	
	while(1)
	{
		LEDdisplay(ir_value);
	}
}

/*******************************************************************************
* 函 数 名 ：Exit0Int
* 函数功能 ：外部中断0 ISR
* 输    入 ：无
* 输    出 ：无
*******************************************************************************/
void Exit0Int() interrupt 0 
{
  unsigned char j,k,N=0;

     EX0 = 0;   
	 DelayIr(15);
	 if (IRIN==1) 
     { EX0 =1;
	   return;
	  } 
                           //确认IR信号出现
  while (!IRIN)            //等IR变为高电平，跳过9ms的前导低电平信号。
    {DelayIr(1);}

 for (j=0;j<4;j++)         //收集四组数据
 { 
  for (k=0;k<8;k++)        //每组数据有8位
  {
   while (IRIN)            //等 IR 变为低电平，跳过4.5ms的前导高电平信号。
     {DelayIr(1);}
    while (!IRIN)          //等 IR 变为高电平
     {DelayIr(1);}
     while (IRIN)           //计算IR高电平时长
      {
    DelayIr(1);
    N++;           
    if (N>=30)
	 { EX0=1;
	 return;}                  //0.14ms计数过长自动离开。
      }                        //高电平计数完毕                
     IRCOM[j]=IRCOM[j] >> 1;                  //数据最高位补“0”
     if (N>=8) {IRCOM[j] = IRCOM[j] | 0x80;}  //数据最高位补“1”
     N=0;
  }//end for k
 }//end for j
   
   if (IRCOM[2]!=~IRCOM[3])
   { EX0=1;
     return; }
   ir_value = IRCOM[2];
     EX0 = 1; 
} 




